[
  {
    "date": "2026-02-02",
    "projects": [
      {
        "name": "stark-v: A general purpose zkVM building on top of Stwo",
        "url": "https://github.com/AntoineFONDEUR/stark-v",
        "type": "开源",
        "tags": [
          "AntoineFONDEUR",
          "Stwo"
        ],
        "summary": {
          "zh": "@AntoineFONDEUR 开源了stark-v，这是一个基于Stwo构建的通用zkVM，为RISC-V程序执行生成STARK证明，支持快速约束开发。",
          "en": "@AntoineFONDEUR open-sourced stark-v, a general-purpose zkVM built on Stwo that generates STARK proofs for RISC-V program execution, enabling rapid constraint development."
        },
        "notes": {
          "zh": [
            "stark-v 是一个RV32IM zkVM，为RISC-V程序执行生成STARK证明。",
            "使用声明式宏生成Stwo AIR组件，加速新约束的开发过程。",
            "提供内存布局定义，支持固定地址范围的程序代码、输入输出和堆栈。",
            "包含基准测试，测量证明吞吐量（kHz），并探索并行化策略。",
            "项目仍在开发中，暂不建议用于生产环境。",
            "架构灵感来源于OpenVM，支持多种分配器如jemalloc、mimalloc。"
          ],
          "en": [
            "stark-v is an RV32IM zkVM that generates STARK proofs for RISC-V program execution.",
            "Uses declarative macros to generate Stwo AIR components for rapid constraint development.",
            "Defines fixed memory layout for program code, input/output, and stack in guest programs.",
            "Includes benchmarks measuring proof throughput (kHz) and explores parallelization strategies.",
            "Project is a work in progress and not yet ready for production use.",
            "Architecture inspired by OpenVM, supports allocators like jemalloc and mimalloc."
          ]
        },
        "slogan": {
          "zh": "【ZK开源】RISC-V zkVM新星：stark-v 基于Stwo构建，支持快速STARK证明生成"
        }
      }
    ],
    "qas": [
      {
        "level": "beginner",
        "question": {
          "zh": "stark-v 支持哪种 RISC-V 架构，有什么限制？",
          "en": "Which RISC-V architecture does stark-v support, and what are its limitations?"
        },
        "answer": {
          "zh": "stark-v 目前支持 RV32IM 指令集，覆盖基础整数运算与乘法扩展。项目仍处于开发阶段，不保证完整生态兼容性，也暂不适合直接用于生产级 zkVM 场景。",
          "en": "stark-v currently supports the RV32IM instruction set, covering base integer operations and multiplication. The project is still under active development and is not yet suitable for production grade zkVM deployments."
        }
      },
      {
        "level": "intermediate",
        "question": {
          "zh": "stark-v 如何加速 AIR 与约束的开发？",
          "en": "How does stark-v accelerate AIR and constraint development?"
        },
        "answer": {
          "zh": "stark-v 使用声明式宏自动生成 Stwo AIR 组件，将指令语义直接映射为约束结构。这种方式减少了手写 AIR 的复杂度，使新增指令或内存约束更接近常规系统实现逻辑。",
          "en": "stark-v uses declarative macros to generate Stwo AIR components automatically, mapping instruction semantics directly into constraints. This reduces manual AIR boilerplate and makes adding new instructions or memory constraints closer to normal systems programming."
        }
      },
      {
        "level": "expert",
        "question": {
          "zh": "stark-v 在 zkVM 设计空间中扮演什么角色？",
          "en": "What role does stark-v play in the zkVM design space?"
        },
        "answer": {
          "zh": "stark-v 更偏向研究型 zkVM，强调 STARK 友好的架构、可组合 AIR 设计以及快速迭代。它为探索 zkVM 中指令级约束、内存建模和并行证明策略提供了实验平台。",
          "en": "stark-v serves as a research oriented zkVM, emphasizing STARK friendly architecture, composable AIR design, and rapid iteration. It provides an experimental platform for studying instruction level constraints, memory modeling, and parallel proof strategies."
        }
      }
    ]
  },
  {
    "date": "2026-02-03",
    "projects": [
      {
        "name": "zkCraft: Prompt-Guided LLM as a Zero-Shot Mutation Pattern Oracle for TCCT-Powered ZK Fuzzing",
        "url": "https://arxiv.org/abs/2602.00667",
        "type": "论文",
        "tags": [
          "Rong Fu",
          "Fuzzing",
          "Automated Debugging"
        ],
        "summary": {
          "zh": "Fu等人在{{name}}论文中提出了zkCraft框架，结合确定性定位与证明搜索来检测ZK电路语义不一致，利用LLM引导突变模板提升边缘案例覆盖，减少求解器交互成本。",
          "en": "Fu et al. proposed the zkCraft framework in their {{name}}paper, combining deterministic localization with proof search to detect semantic inconsistencies in ZK circuits, using LLM-guided mutation templates to improve edge-case coverage and reduce solver interaction costs."
        },
        "notes": {
          "zh": [
            "ZK电路因见证计算与约束紧密耦合而难以正确实现，易产生语义不一致",
            "zkCraft框架结合确定性R1CS感知定位与证明承载搜索，检测欠约束和过约束故障",
            "将候选约束编辑编码为Row-Vortex多项式，用Violation IOP替代重复求解器查询，提供简洁证明",
            "确定性LLM驱动突变模板偏向探索边缘案例，同时保持可审计的代数验证",
            "在真实Circom代码评估中，证明承载定位检测多种故障，假阳性低，减少求解器交互成本",
            "该方法连接形式验证与自动调试，为稳健ZK电路开发提供可扩展路径"
          ],
          "en": [
            "ZK circuits are tricky due to tight witness-constraint coupling, causing subtle bugs.",
            "zkCraft uses R1CS-aware localization and proof search to catch under/over-constrained issues.",
            "Row-Vortex polynomials encode edits; Violation IOP replaces repeated solver checks with a proof.",
            "LLM-guided mutations target edge cases, keeping algebraic verification auditable.",
            "Tested on Circom, zkCraft finds diverse bugs, lowers false positives and solver costs.",
            "Links formal verification with automated debugging for scalable ZK circuit development."
          ]
        },
        "slogan": {
          "zh": "【ZK论文】zkCraft：用LLM引导的突变模板，自动检测ZK电路语义错误"
        }
      }
    ],
    "qas": [
      {
        "level": "beginner",
        "question": {
          "zh": "为什么 ZK 电路中的语义错误很难通过普通测试发现？",
          "en": "Why are semantic bugs in ZK circuits hard to detect with conventional testing?"
        },
        "answer": {
          "zh": "ZK 电路中见证计算与约束系统高度耦合，很多错误不会直接导致约束不满足，而是悄然放宽或收紧可行解空间。普通测试往往只覆盖少量输入，难以触及这些隐藏的欠约束或过约束情况。",
          "en": "In ZK circuits, witness computation is tightly coupled with constraints, so many bugs do not immediately violate constraints. Instead, they silently widen or restrict the solution space. Standard testing covers limited inputs and often misses such under- or over-constrained cases."
        }
      },
      {
        "level": "intermediate",
        "question": {
          "zh": "Row-Vortex 多项式在 zkCraft 中解决了什么关键瓶颈？",
          "en": "What key bottleneck does the Row-Vortex polynomial address in zkCraft?"
        },
        "answer": {
          "zh": "Row-Vortex 多项式将候选约束修改统一编码，使大量潜在违规可以被一次性代数化检查。这避免了对每个候选编辑单独调用求解器的问题，显著提升了搜索阶段的效率。",
          "en": "The Row-Vortex polynomial encodes many candidate constraint edits into a single algebraic object. This allows zkCraft to check many potential violations at once, avoiding per-edit solver calls and greatly improving search efficiency."
        }
      },
      {
        "level": "expert",
        "question": {
          "zh": "Violation IOP 在 zkCraft 中如何替代多次可满足性检查？",
          "en": "How does the Violation IOP replace repeated satisfiability checks in zkCraft?"
        },
        "answer": {
          "zh": "Violation IOP 将约束违规转化为可验证的代数证明，使验证者只需检查一个简洁证明即可确认错误存在。这将交互式、反复的可满足性查询转化为一次性证明验证。",
          "en": "The Violation IOP turns constraint violations into succinct algebraic proofs. A verifier checks a single proof to confirm the existence of a bug, replacing interactive and repeated satisfiability queries with one proof verification."
        }
      }
    ]
  },
  {
    "date": "2026-02-04",
    "projects": [
      {
        "name": "Field-Agnostic SNARKs from Expand-Accumulate Codes",
        "url": "https://eprint.iacr.org/2024/1871",
        "type": "论文",
        "tags": [
          "Alexander R. Block",
          "Brakedown"
        ],
        "summary": {
          "zh": "Block等人在{{name}}论文中提出了一种基于扩展累积码的域无关SNARK，解决了现有方案依赖特定有限域的问题，证明生成时间仅需0.23秒，比非域无关方案快两个数量级。",
          "en": "Block et al. proposed a field-agnostic SNARK based on expand-accumulate codes in their {{name}}paper, addressing the limitation of existing schemes that rely on specific finite fields, with proof generation time as low as 0.23 seconds, two orders of magnitude faster than non-field-agnostic SNARKs."
        },
        "notes": {
          "zh": [
            "提出基于扩展累积码的域无关SNARK，不依赖特定有限域",
            "主要技术贡献：证明这些码具有恒定速率和相对距离，解决先前开放问题",
            "证明者时间为O(M log M)，证明大小为O(√M)，具体效率显著提升",
            "ECDSA验证在secp256k1曲线上证明生成仅需0.23秒，比非域无关方案快100倍",
            "相比Brakedown，证明大小减少1.9-2.8倍，证明者时间仅增加1.2倍开销",
            "具有透明设置和潜在的后量子安全性，适用于多种实际应用场景"
          ],
          "en": [
            "Proposed a field-agnostic SNARK based on expand-accumulate codes, independent of specific finite fields",
            "Key technical contribution: proved these codes have constant rate and relative distance, solving an open problem",
            "Prover time O(M log M), proof size O(√M), with significant concrete efficiency improvements",
            "ECDSA verification on secp256k1 requires only 0.23s proof generation, 100x faster than non-field-agnostic SNARKs",
            "Compared to Brakedown, proof size reduced by 1.9-2.8x with only 1.2x overhead in prover time",
            "Features transparent setup and plausible post-quantum security, suitable for various practical applications"
          ]
        },
        "slogan": {
          "zh": "【ZK论文】突破域限制：新型SNARK实现高效通用证明"
        }
      }
    ],
    "qas": [
      {
        "level": "beginner",
        "variant": 1,
        "question": {
          "zh": "为什么“域无关”对 SNARK 来说是一个重要特性？",
          "en": "Why is being field-agnostic an important property for SNARKs?"
        },
        "answer": {
          "zh": "许多实际密码算法运行在特定有限域或椭圆曲线标量域上。传统 SNARK 若强制使用特定域，往往需要昂贵的域嵌入。域无关 SNARK 可以直接在原生域上工作，大幅降低证明开销。",
          "en": "Many real-world cryptographic algorithms operate over specific finite fields or curve scalar fields. Traditional SNARKs often require costly field embeddings. Field-agnostic SNARKs work directly over the native field, significantly reducing overhead."
        }
      },
      {
        "level": "intermediate",
        "question": {
          "zh": "证明扩展累积码具有恒定速率和相对距离为何重要？",
          "en": "Why is proving constant rate and relative distance for expand-accumulate codes important?"
        },
        "answer": {
          "zh": "恒定速率和相对距离是构建高效 SNARK 的关键编码性质。该结果解决了一个长期开放问题，保证了在规模扩展时，证明大小和可靠性不会迅速恶化。",
          "en": "Constant rate and relative distance are crucial coding properties for efficient SNARKs. This result resolves a long-standing open problem and ensures proof size and soundness do not degrade as the system scales."
        }
      },
      {
        "level": "expert",
        "question": {
          "zh": "O(M log M) 的证明者复杂度在实践中意味着什么？",
          "en": "What does an O(M log M) prover complexity imply in practice?"
        },
        "answer": {
          "zh": "该复杂度避免了对域特定 FFT 的依赖，使实现更通用且工程友好。在实际规模下，常数因子较小，使得在复杂电路如 ECDSA 验证中也能实现亚秒级证明。",
          "en": "This complexity avoids reliance on field-specific FFTs, making implementations more general and engineering-friendly. With small constants, it enables sub-second proofs even for complex circuits like ECDSA verification."
        }
      }
    ]
  },
  {
    "date": "2026-02-05",
    "projects": [
      {
        "name": "Hachi: Efficient Lattice-Based Multilinear Polynomial Commitments over Extension Fields",
        "url": "https://eprint.iacr.org/2026/156",
        "type": "论文",
        "tags": [
          "Ngoc Khanh Nguyen",
          "Lattice",
          "Sumcheck"
        ],
        "summary": {
          "zh": "Nguyen等人在{{name}}论文中提出了Hachi，一种基于格的多线性多项式承诺方案，通过结合Greyhound与环切换技术，实现了验证时间的平方根复杂度提升和约55KB的紧凑证明。",
          "en": "Nguyen et al. proposed Hachi, a lattice-based multilinear polynomial commitment scheme in their {{name}}paper, achieving square-root verification time and compact proofs (~55KB) by integrating Greyhound with ring-switching."
        },
        "notes": {
          "zh": [
            "Hachi基于Module-SIS假设，为ℓ变量多项式提供poly(ℓ,λ)大小的证明和Õ(√2^ℓλ)验证时间",
            "相比当前最优方案Greyhound，验证时间渐进改进Õ(λ)，实际加速达12.5倍",
            "采用sumcheck协议优化验证，但标准sumcheck在格构造中存在效率瓶颈",
            "创新结合Greyhound与环切换技术，使验证器无需在R_q上进行乘法运算",
            "引入通用归约，将扩展域F_{q^k}上的多项式求值证明转换为分圆环R_q上的等价陈述",
            "该技术可独立应用于构建基于格的SNARK，特别适用于实现更快验证"
          ],
          "en": [
            "Hachi offers poly(ℓ,λ) proof size and Õ(√2^ℓλ) verifier time for ℓ-variate polynomials under Module-SIS",
            "Achieves Õ(λ) asymptotic improvement over Greyhound, with 12.5x practical speedup",
            "Uses sumcheck protocol but addresses bottlenecks in lattice-based constructions",
            "Novel integration of Greyhound with ring-switching eliminates R_q multiplications for verifier",
            "Generic reduction converts extension field proofs to cyclotomic ring statements",
            "Technique applicable to lattice-based SNARKs for faster verification"
          ]
        },
        "slogan": {
          "zh": "【ZK论文】格密码新突破：Hachi实现高效多项式承诺，验证速度提升12.5倍"
        }
      }
    ],
    "qas": [
      {
        "level": "beginner",
        "question": {
          "zh": "在基于格的多项式承诺方案中，为什么验证时间往往会成为瓶颈？",
          "en": "Why does verifier time often become a bottleneck in lattice-based polynomial commitment schemes?"
        },
        "answer": {
          "zh": "在基于格的多项式承诺中，验证多线性多项式通常需要大量代数运算。验证过程涉及昂贵的环乘法和规范检查，使验证器成本随问题规模快速增长，从而限制系统的可扩展性。",
          "en": "In lattice-based polynomial commitment schemes, verifying multilinear polynomials requires substantial algebraic computation. The verifier must perform costly ring operations and norm checks, causing its cost to grow quickly with the problem size and limiting scalability."
        }
      },
      {
        "level": "intermediate",
        "question": {
          "zh": "标准 sumcheck 在格基构造中面临哪些效率问题？",
          "en": "What efficiency issues does standard sumcheck face in lattice-based constructions?"
        },
        "answer": {
          "zh": "标准 sumcheck 假设高效的域运算，但在格构造中，验证者往往需要在环 R_q 上执行多次乘法。这些操作代价高昂，使得直接套用 sumcheck 会显著拖慢验证过程。",
          "en": "Standard sumcheck assumes cheap field operations, but in lattice settings the verifier must often perform many multiplications over the ring R_q. These operations are expensive, making naive sumcheck inefficient."
        }
      },
      {
        "level": "expert",
        "question": {
          "zh": "将扩展域证明归约到分圆环在设计上有何深远影响？",
          "en": "What are the broader design implications of reducing extension-field proofs to cyclotomic rings?"
        },
        "answer": {
          "zh": "这一通用归约表明，复杂扩展域上的多项式验证可以映射到更受控的环结构中。这不仅提升了验证效率，也为构建模块化、可复用的格基 SNARK 组件提供了新范式。",
          "en": "This generic reduction shows that polynomial verification over extension fields can be mapped to more structured ring settings. It improves verifier efficiency and enables a modular, reusable design paradigm for lattice-based SNARK components."
        }
      }
    ]
  }
]