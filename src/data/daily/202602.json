[
  {
    "date": "2026-02-02",
    "projects": [
      {
        "name": "stark-v: A general purpose zkVM building on top of Stwo",
        "url": "https://github.com/AntoineFONDEUR/stark-v",
        "type": "开源",
        "tags": [
          "AntoineFONDEUR",
          "Stwo"
        ],
        "summary": {
          "zh": "@AntoineFONDEUR 开源了stark-v，这是一个基于Stwo构建的通用zkVM，为RISC-V程序执行生成STARK证明，支持快速约束开发。",
          "en": "@AntoineFONDEUR open-sourced stark-v, a general-purpose zkVM built on Stwo that generates STARK proofs for RISC-V program execution, enabling rapid constraint development."
        },
        "notes": {
          "zh": [
            "stark-v 是一个RV32IM zkVM，为RISC-V程序执行生成STARK证明。",
            "使用声明式宏生成Stwo AIR组件，加速新约束的开发过程。",
            "提供内存布局定义，支持固定地址范围的程序代码、输入输出和堆栈。",
            "包含基准测试，测量证明吞吐量（kHz），并探索并行化策略。",
            "项目仍在开发中，暂不建议用于生产环境。",
            "架构灵感来源于OpenVM，支持多种分配器如jemalloc、mimalloc。"
          ],
          "en": [
            "stark-v is an RV32IM zkVM that generates STARK proofs for RISC-V program execution.",
            "Uses declarative macros to generate Stwo AIR components for rapid constraint development.",
            "Defines fixed memory layout for program code, input/output, and stack in guest programs.",
            "Includes benchmarks measuring proof throughput (kHz) and explores parallelization strategies.",
            "Project is a work in progress and not yet ready for production use.",
            "Architecture inspired by OpenVM, supports allocators like jemalloc and mimalloc."
          ]
        },
        "slogan": {
          "zh": "【ZK开源】RISC-V zkVM新星：stark-v 基于Stwo构建，支持快速STARK证明生成"
        }
      }
    ],
    "qas": [
      {
        "level": "beginner",
        "question": {
          "zh": "stark-v 支持哪种 RISC-V 架构，有什么限制？",
          "en": "Which RISC-V architecture does stark-v support, and what are its limitations?"
        },
        "answer": {
          "zh": "stark-v 目前支持 RV32IM 指令集，覆盖基础整数运算与乘法扩展。项目仍处于开发阶段，不保证完整生态兼容性，也暂不适合直接用于生产级 zkVM 场景。",
          "en": "stark-v currently supports the RV32IM instruction set, covering base integer operations and multiplication. The project is still under active development and is not yet suitable for production grade zkVM deployments."
        }
      },
      {
        "level": "intermediate",
        "question": {
          "zh": "stark-v 如何加速 AIR 与约束的开发？",
          "en": "How does stark-v accelerate AIR and constraint development?"
        },
        "answer": {
          "zh": "stark-v 使用声明式宏自动生成 Stwo AIR 组件，将指令语义直接映射为约束结构。这种方式减少了手写 AIR 的复杂度，使新增指令或内存约束更接近常规系统实现逻辑。",
          "en": "stark-v uses declarative macros to generate Stwo AIR components automatically, mapping instruction semantics directly into constraints. This reduces manual AIR boilerplate and makes adding new instructions or memory constraints closer to normal systems programming."
        }
      },
      {
        "level": "expert",
        "question": {
          "zh": "stark-v 在 zkVM 设计空间中扮演什么角色？",
          "en": "What role does stark-v play in the zkVM design space?"
        },
        "answer": {
          "zh": "stark-v 更偏向研究型 zkVM，强调 STARK 友好的架构、可组合 AIR 设计以及快速迭代。它为探索 zkVM 中指令级约束、内存建模和并行证明策略提供了实验平台。",
          "en": "stark-v serves as a research oriented zkVM, emphasizing STARK friendly architecture, composable AIR design, and rapid iteration. It provides an experimental platform for studying instruction level constraints, memory modeling, and parallel proof strategies."
        }
      }
    ]
  },
  {
    "date": "2026-02-03",
    "projects": [
      {
        "name": "zkCraft: Prompt-Guided LLM as a Zero-Shot Mutation Pattern Oracle for TCCT-Powered ZK Fuzzing",
        "url": "https://arxiv.org/abs/2602.00667",
        "type": "论文",
        "tags": [
          "Rong Fu",
          "Fuzzing",
          "Automated Debugging"
        ],
        "summary": {
          "zh": "Fu等人在{{name}}论文中提出了zkCraft框架，结合确定性定位与证明搜索来检测ZK电路语义不一致，利用LLM引导突变模板提升边缘案例覆盖，减少求解器交互成本。",
          "en": "Fu et al. proposed the zkCraft framework in their {{name}}paper, combining deterministic localization with proof search to detect semantic inconsistencies in ZK circuits, using LLM-guided mutation templates to improve edge-case coverage and reduce solver interaction costs."
        },
        "notes": {
          "zh": [
            "ZK电路因见证计算与约束紧密耦合而难以正确实现，易产生语义不一致",
            "zkCraft框架结合确定性R1CS感知定位与证明承载搜索，检测欠约束和过约束故障",
            "将候选约束编辑编码为Row-Vortex多项式，用Violation IOP替代重复求解器查询，提供简洁证明",
            "确定性LLM驱动突变模板偏向探索边缘案例，同时保持可审计的代数验证",
            "在真实Circom代码评估中，证明承载定位检测多种故障，假阳性低，减少求解器交互成本",
            "该方法连接形式验证与自动调试，为稳健ZK电路开发提供可扩展路径"
          ],
          "en": [
            "ZK circuits are tricky due to tight witness-constraint coupling, causing subtle bugs.",
            "zkCraft uses R1CS-aware localization and proof search to catch under/over-constrained issues.",
            "Row-Vortex polynomials encode edits; Violation IOP replaces repeated solver checks with a proof.",
            "LLM-guided mutations target edge cases, keeping algebraic verification auditable.",
            "Tested on Circom, zkCraft finds diverse bugs, lowers false positives and solver costs.",
            "Links formal verification with automated debugging for scalable ZK circuit development."
          ]
        },
        "slogan": {
          "zh": "【ZK论文】zkCraft：用LLM引导的突变模板，自动检测ZK电路语义错误"
        }
      }
    ],
    "qas": [
      {
        "level": "beginner",
        "question": {
          "zh": "为什么 ZK 电路中的语义错误很难通过普通测试发现？",
          "en": "Why are semantic bugs in ZK circuits hard to detect with conventional testing?"
        },
        "answer": {
          "zh": "ZK 电路中见证计算与约束系统高度耦合，很多错误不会直接导致约束不满足，而是悄然放宽或收紧可行解空间。普通测试往往只覆盖少量输入，难以触及这些隐藏的欠约束或过约束情况。",
          "en": "In ZK circuits, witness computation is tightly coupled with constraints, so many bugs do not immediately violate constraints. Instead, they silently widen or restrict the solution space. Standard testing covers limited inputs and often misses such under- or over-constrained cases."
        }
      },
      {
        "level": "intermediate",
        "question": {
          "zh": "Row-Vortex 多项式在 zkCraft 中解决了什么关键瓶颈？",
          "en": "What key bottleneck does the Row-Vortex polynomial address in zkCraft?"
        },
        "answer": {
          "zh": "Row-Vortex 多项式将候选约束修改统一编码，使大量潜在违规可以被一次性代数化检查。这避免了对每个候选编辑单独调用求解器的问题，显著提升了搜索阶段的效率。",
          "en": "The Row-Vortex polynomial encodes many candidate constraint edits into a single algebraic object. This allows zkCraft to check many potential violations at once, avoiding per-edit solver calls and greatly improving search efficiency."
        }
      },
      {
        "level": "expert",
        "question": {
          "zh": "Violation IOP 在 zkCraft 中如何替代多次可满足性检查？",
          "en": "How does the Violation IOP replace repeated satisfiability checks in zkCraft?"
        },
        "answer": {
          "zh": "Violation IOP 将约束违规转化为可验证的代数证明，使验证者只需检查一个简洁证明即可确认错误存在。这将交互式、反复的可满足性查询转化为一次性证明验证。",
          "en": "The Violation IOP turns constraint violations into succinct algebraic proofs. A verifier checks a single proof to confirm the existence of a bug, replacing interactive and repeated satisfiability queries with one proof verification."
        }
      }
    ]
  }
]